# -*- coding: utf-8 -*-
"""CondenserApp.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UtVZ2bnmfSYyoFSzPFQQFnYX4ROdq0Wj
"""

import json
from pathlib import Path

import numpy as np
import pandas as pd
import streamlit as st


# ------------------------------
# Load backend JSON (relative path)
# ------------------------------
DATA_PATH = Path(__file__).parent / "data" / "condenser_backend.json"

@st.cache_data
def load_backend():
    with open(DATA_PATH, "r", encoding="utf-8") as f:
        return json.load(f)

backend = load_backend()
solvent_rows = backend.get("solvents", [])


# ------------------------------
# Solvent lookup helpers
# ------------------------------
def normalize(s: str) -> str:
    return str(s).strip().lower()

# Build a lookup dict: normalized solvent -> properties dict
solvent_lookup = {}
for r in solvent_rows:
    key = normalize(r.get("Solvent", ""))
    if key:
        solvent_lookup[key] = r

solvent_list = sorted([r["Solvent"] for r in solvent_rows if "Solvent" in r])


def get_solvent_properties(solvent_name: str) -> dict:
    key = normalize(solvent_name)
    # exact
    if key in solvent_lookup:
        r = solvent_lookup[key]
        return {
            "BP_C": float(r["BoilingPoint_C"]),
            "LatentHeat_kcal_per_kg": float(r["LatentHeat_kcal_per_kg"]),
            "Density_kg_per_L": float(r["Density_g_per_ml"]),  # g/mL == kg/L numerically
            "Cp_kcal_per_kgC": float(r["Cp_kcal_per_kgC"]),
        }
    # contains (fallback)
    for k, r in solvent_lookup.items():
        if key and key in k:
            return {
                "BP_C": float(r["BoilingPoint_C"]),
                "LatentHeat_kcal_per_kg": float(r["LatentHeat_kcal_per_kg"]),
                "Density_kg_per_L": float(r["Density_g_per_ml"]),
                "Cp_kcal_per_kgC": float(r["Cp_kcal_per_kgC"]),
            }
    return {}


# ------------------------------
# App UI
# ------------------------------
st.title("Condenser Sizing Tool")

st.sidebar.header("Inputs")

solvent = st.sidebar.selectbox("Solvent", solvent_list, index=0)

Volume_of_Distillation = st.sidebar.number_input("Volume of Distillation (L)", value=1600.0, min_value=0.0, step=10.0)
Vapor_Rate = st.sidebar.number_input("Vapor Rate (L/hr)", value=800.0, min_value=0.0, step=10.0)
Distillate_Outlet_Temp = st.sidebar.number_input("Distillate Outlet Temperature (°C)", value=65.0, step=1.0)

U = st.sidebar.number_input("Overall HTC, U (kcal/hr·m²·K)", value=150.0, min_value=0.0, step=5.0)
fouling_factor = st.sidebar.number_input("Fouling factor (multiplier)", value=0.6, min_value=0.01, max_value=5.0, step=0.05)

Utility_velocity = st.sidebar.number_input("Utility velocity (m/s)", value=1.0, min_value=0.01, step=0.1)
Utility_Heat_Capacity = st.sidebar.number_input("Utility Cp (kcal/kg·°C)", value=0.95, min_value=0.01, step=0.01)

dT_limit = st.sidebar.number_input("Utility ΔT limit (°C)", value=5.0, min_value=0.1, step=0.5)

Pipe_Dia_List = [1, 1.5, 2, 2.5, 3]

# Utility master data (you can later make these editable if needed)
df_utility = pd.DataFrame({
    "Utility": ["Cooling Water", "Chilling Water", "Brine Water"],
    "Inlet_Temp (degree C)": [30, 15, 0],
    "Density (kg/ cubic m)": [1000, 1000, 1000],
})
max_utility_inlet = float(df_utility["Inlet_Temp (degree C)"].max())


# ------------------------------
# Validate distillate outlet temperature
# ------------------------------
if Distillate_Outlet_Temp <= max_utility_inlet:
    st.error(
        f"Distillate Outlet Temperature ({Distillate_Outlet_Temp:.2f} °C) must be > "
        f"maximum utility inlet temperature ({max_utility_inlet:.2f} °C). "
        f"Please increase Distillate Outlet Temp."
    )
    st.stop()


# ------------------------------
# Computation
# ------------------------------
props = get_solvent_properties(solvent)
if not props:
    st.error("Solvent not found in condenser_backend.json.")
    st.stop()

BP = props["BP_C"]
Latent_Heat_of_Vaporization = props["LatentHeat_kcal_per_kg"]
Density_of_Substance = props["Density_kg_per_L"]
Cp = props["Cp_kcal_per_kgC"]

Q = Vapor_Rate * Density_of_Substance * (Cp * (BP - Distillate_Outlet_Temp) + Latent_Heat_of_Vaporization)  # kcal/hr
time_hr = Volume_of_Distillation / Vapor_Rate if Vapor_Rate > 0 else np.nan

st.subheader("Calculated Summary")
c1, c2, c3 = st.columns(3)
c1.metric("Heat Load Q (kcal/hr)", f"{Q:,.2f}")
c2.metric("Distillation Time (hr)", f"{time_hr:,.2f}" if np.isfinite(time_hr) else "—")
c3.metric("Boiling Point (°C)", f"{BP:,.2f}")

st.write(
    f"**Solvent props:** Density={Density_of_Substance:.4f} kg/L, Cp={Cp:.4f} kcal/kg·°C, "
    f"Latent Heat={Latent_Heat_of_Vaporization:.2f} kcal/kg"
)

utility_order = list(range(df_utility.shape[0]))  # Cooling -> Chilling -> Brine

trial_log = []
selected = None

for d_inch in Pipe_Dia_List:
    d_m = d_inch * 0.0254
    pipe_area = np.pi * (d_m / 2) ** 2  # m²

    for j in utility_order:
        Utility_Name = str(df_utility.iloc[j, 0])
        Utility_Inlet_Temp = float(df_utility.iloc[j, 1])
        Utility_Density = float(df_utility.iloc[j, 2])

        m_dot = Utility_Density * pipe_area * Utility_velocity * 3600  # kg/hr
        Utility_Outlet_Temp = Utility_Inlet_Temp + Q / (m_dot * Utility_Heat_Capacity)
        dT = Utility_Outlet_Temp - Utility_Inlet_Temp

        delT1 = BP - Utility_Outlet_Temp
        delT2 = Distillate_Outlet_Temp - Utility_Inlet_Temp

        if delT1 <= 0 or delT2 <= 0:
            LMTD = np.nan
            HTA = np.nan
            status = "ERROR: Non-positive driving force"
        else:
            if abs(delT1 - delT2) < 1e-12:
                LMTD = delT1
            else:
                LMTD = (delT1 - delT2) / np.log(delT1 / delT2)
            HTA = Q / (U * LMTD * fouling_factor)
            status = "OK"

        row = {
            "Dia_inch": d_inch,
            "Utility": Utility_Name,
            "Tin_C": Utility_Inlet_Temp,
            "Tout_C": Utility_Outlet_Temp,
            "dT_C": dT,
            "Pass_dT<=limit": (dT <= dT_limit),
            "MassRate_kg_hr": m_dot,
            "LMTD_C": LMTD,
            "HTA_m2": HTA,
            "Status": status,
        }
        trial_log.append(row)

        # Select first feasible option by ΔT (and valid HTA)
        if selected is None and (dT <= dT_limit) and (status == "OK"):
            selected = row
            break

    if selected is not None:
        break

trial_df = pd.DataFrame(trial_log)

st.subheader("All Trials (Dia × Utility)")
st.dataframe(trial_df, use_container_width=True)

if selected is None:
    st.warning(
        "No feasible option found with ΔT ≤ limit.\n\n"
        "Try:\n"
        "- Higher utility dia list\n"
        "- Higher utility velocity\n"
        "- Reduce vapor rate"
    )
    st.stop()

st.subheader("Selected Option (first feasible by ΔT)")
st.write(
    f"**Utility:** {selected['Utility']}\n\n"
    f"**Pipe Dia:** {selected['Dia_inch']} inch\n\n"
    f"**Utility Tin/Tout:** {selected['Tin_C']:.2f} → {selected['Tout_C']:.2f} °C  (ΔT={selected['dT_C']:.2f} °C)\n\n"
    f"**Utility Mass rate:** {selected['MassRate_kg_hr']:.2f} kg/hr\n\n"
    f"**LMTD:** {selected['LMTD_C']:.4f} °C\n\n"
    f"**HTA (Area):** {selected['HTA_m2']:.4f} m²\n"
)

# ------------------------------
# Alternatives at SAME selected dia (if cooling selected)
# ------------------------------
if normalize(selected["Utility"]) == "cooling water":
    selected_dia = float(selected["Dia_inch"])
    d_m = selected_dia * 0.0254
    pipe_area = np.pi * (d_m / 2) ** 2

    alt_results = []
    for util_name in ["Chilling Water", "Brine Water"]:
        row_u = df_utility[df_utility["Utility"] == util_name].iloc[0]
        Tin = float(row_u["Inlet_Temp (degree C)"])
        rho = float(row_u["Density (kg/ cubic m)"])

        m_dot = rho * pipe_area * Utility_velocity * 3600
        Tout = Tin + Q / (m_dot * Utility_Heat_Capacity)
        dT = Tout - Tin

        delT1 = BP - Tout
        delT2 = Distillate_Outlet_Temp - Tin

        if delT1 <= 0 or delT2 <= 0:
            LMTD = np.nan
            HTA = np.nan
            status = "ERROR: Non-positive driving force"
        else:
            if abs(delT1 - delT2) < 1e-12:
                LMTD = delT1
            else:
                LMTD = (delT1 - delT2) / np.log(delT1 / delT2)
            HTA = Q / (U * LMTD * fouling_factor)
            status = "OK"

        alt_results.append({
            "Utility": util_name,
            "Tin_C": Tin,
            "Tout_C": Tout,
            "dT_C": dT,
            "Pass_dT<=limit": (dT <= dT_limit),
            "LMTD_C": LMTD,
            "HTA_m2": HTA,
            "Status": status,
        })

    alt_df = pd.DataFrame(alt_results)

    st.subheader(f"Alternatives at SAME Pipe Dia = {selected_dia} inch")
    st.dataframe(alt_df, use_container_width=True)

    st.info(
        "If HTA is geometrically constrained:\n"
        "- Prefer the alternative utility with **lower HTA** (only if Pass_dT<=limit is True)\n"
        "- If still high: **Decrease vapor rate**"
    )

# Optional: geometric constraint helper
st.subheader("Geometric constraint check (optional)")
area_limit = st.number_input("Max allowable area (m²) [optional]", value=0.0, min_value=0.0, step=1.0)
if area_limit > 0:
    if selected["HTA_m2"] > area_limit:
        factor = area_limit / selected["HTA_m2"]
        suggested_vapor = Vapor_Rate * factor
        st.warning(
            f"HTA = {selected['HTA_m2']:.2f} m² is > limit {area_limit:.2f} m².\n\n"
            f"Suggestion:\n"
            f"- Reduce Vapor Rate approximately to **{suggested_vapor:.2f} L/hr** (from {Vapor_Rate:.2f} L/hr)."
        )
    else:
        st.success("Selected HTA is within the allowable area limit.")
